# 답변형 게시판
1. 주요기능
	1) 전체글 리스트
		block단위 페이징
			- 한 번에 보일 데이터 건수 설정(3/5/10/20...)			
				[1][2][3][4][5] >>
				<< [5][6][7][8][9]
		검색
		계층형 답글 달기
	2) 글 등록
		첨부파일
	3) 상세화면
		수정
		삭제
		파일 다운로드
		답글
		
# DB 설계 및 VO 만들기		
	1) DB 설계 및 테이블 구성
		board: 번호, 상위 번호, 제목, 작성자, 등록일, 수정일, 조회수, 내용
			   no, refno, subject, writer, regdte, uptdte, readcnt, content
		boardfile: 번호, 파일명, 경로명, 내용, 생성일
				   no, fname, pathname, content, credte
		board_seq (sequence 만들기)		
	2) VO 작성
		리스트/입력 처리 VO(board.z01_vo.Board)
		-- 조회처리 및 페이지 처리 관련 VO
		첨부파일 VO(board.z01_vo.Boardfile)

# 기본 조회 리스트 작성
	1) SQL
		SELECT * FROM BOARD
		WHERE SUBJECT LIKE '%%'
		AND WRITER LIKE '%%'
		ORDER BY NO DESC;
	2) DAO
		public ArrayList<Board> boardList(Board sch);
	3) MAPPER
			
	4) SERVICE
		board.a02_service.A01_BoardService
	5) CONTROLLER
		modelattribute명 sch
		model명 boardList
	6) JSP(VIEW)
	
	
# 기본 정보 등록
	1) list화면에서 등록 버튼 클릭
		/board.do?method=insForm 으로 등록 화면 이동
	2) Controller 등록화면 선언
	3) 등록 화면: 
		a02_boardInsert.jsp
		form 화면 구성(action=board.do?method=insert)
		> 상위글번호(0, hidden), 글제목, 작성자, 내용, 첨부파일
	4) 등록 SQL
		INSERT INTO board VALUES (BOARD_seq.nextval, 0, '첫 번째 글', '내용', '홍길동', 0, sysdate, sysdate)
	5) DAO
		public void insertBoard(Board insert);
	6) mapper.xml 작성
	7) service
	8) controller
		등록 service 호출
	9) 화면 등록 완료 처리 메시지 출력

# 파일 업로드
1. 다중파일 업로드를 위한 화면 UI 구성(view)
	<input type="file" name="report"/>
2. form 객체의 속성 추가
	<form enctype="multipart/form-data">
3. container에 파일 업로드 view bean추가
	org.springframework.web.multipart.commons.CommonsMultipartResolver
4. VO에서 report라는 프로퍼티로 네트웍상 client에서 server로 전송 가능하게 해주는 MultipartFile 객체 속성 선언
	private MultipartFile[] report;
5. Controller에서 파일이 전송되었는지 확인
6. service단에서 받은 MultipartFile을 File객체로 변환해서
	1) 특정 위치에 저장
		eclipse tomcat 웹 서비스를 사용하기 때문
		- 임시 폴더: 임시 저장(tmpUpload) - info에 위치 설정(절대위치 지정)
		- 파일을 다운로드할 폴더(upload): 임시 폴더에 있는 파일을 추후 다운로드할 폴더에 복사 
			- info에 위치 설정(절대위치 지정)(WebContent\z01_upload)
		- 다운로드 업로드 폴더 위치 지정(WebContent\z01_upload)
		- 임시 폴더에 있는 모든 파일 삭제(예외 방지)
		- MultipartFile 객체(메모리로 파일정보 저장)
			==> File변환(메모리+하드웨어적으로 특정 위치에 파일 저장)
			transferTo()메서드 사용
		- 임시파일 ==> 업로드할 위치로 복사
			파일 카피 정책으로는 기존파일이 있으면 덮어쓰기
	2) DB에 해당 파일 정보를 저장
		(상세화면에서 다운로드 처리를 위해 파일 정보 저장)
		- DB 구조 만들기
			boardfile: 번호, 파일명, 경로명, 내용, 생성일
				   	   no, fname, pathname, content, credte			
		- SQL
			INSERT INTO BOARDFILE(BOARD_SEQ.CURRVAL, #{fname}, #{pathname}, #{content}, sysdate)
			board_seq.currval: 등록하는 main board테이블의 no(board_seq.nextval)와 동일하게 해줌
		- VO만들기: BoardFile
		- DAO
		- 공통 VO 마이바티즈 공통파일 등록, mapper.xml에 SQL 등록
		- Service단에서 호출


# 상세화면		
1. 리스트 화면에서 특정한 row 클릭, no와 함께 Controller 상세화면 처리
2. SQL 작성
	SELECT * FROM BOARD WHERE NO = #{NO}
3. DAO 작성
4. XXXmapper.xml
5. service 호출
6. controller
	- model
	- 상세화면 호출
7. 상세화면에 출력 리스트

# 첨부파일 리스트 및 다운로드
1. SQL 작성
	SELECT * FROM BOARDFILE WHERE NO = #{NO}
2. VO확인
3. DAO
	public ArrayList<BoardFile> getBoardFile(int no);
4. mapper
5. Board VO객체에 첨부파일을 처리할 수 있는 기능 추가 등록
	private ArrayList<BoardFile> fileInfo; + setter/getter
6. Service에서 Board VO에 할당
7. JSP에서 처리

# 조회수 count up 처리
1. SQL
	UPDATE BOARD
		SET READCNT = READCNT+1
	WHERE NO = #{NO}
2. DAO
	public void update(int no);
3. mapper
4. service단에서 호출
	dao.updateBoard(no);
	
# 파일 다운로드
1. 리스트
	board의 FileInfo로 리스트 처리
2. 파일 다운로드 view 등록
	# 파일 다운로드 viewer 작성
	1. API에서 지원되는 부분에서 model데이터로 특정한 파일을 지정해야 하기때문에 사용자 정의로 만들어야 한다.
	2. 사용자 정의 viewer 작성 순서
		- 1. 상속 AbstractView 선언
			1) overriding 메서드 재정의
				- renderMergedOutputModel
					매개변수
					Map<String, Object> model,: 다운로드할 파일명을 할당
					HttpServletRequest request,
					HttpServletResponse response
		- 2. 다운로드
			1) upload 된 파일 가져오기(서버가 가지고 있는 파일)
				- 현재 viewer를 호출 시 사용되는 model 객체 가져오기
				- File 객체 생성
			2) 모델과 함께 있는 File객체 가져오기(서버가 가지고 있는 파일)
			3) 반응 객체(response)로 전달(클라이언트의 파일)
				- 전체 파일명
				- 파일명
				- 파일의 길이
				- setContentType 설정: application/download;charset-utf-8
				- setContentLength로 파일의 길이 설정
				- 한글명된 파일은 Encoding
				- 파일을 response에 탑재하기 위한 header부분 설정
					Content-Disposition으로 attachment로 파일 설정
					Content-Transfer-Encoding 설정. binary 설정
				- 파일을 network로 전송하기 위해 Stream 객체로 변환
					InputStream(읽어오는 객체) ==> OutputStream(보내는 객체)
					FileInputStream(파일 객체)
					FileCopyUtils.copy(InputStream, OutputStream)
					OutputStream의 flush를 통해 자원 해제		
3. 파일을 모델로 파일 다운로드 처리 controller 생성
	- 요청값으로 파일명을 전송
	- model값 파일을 설정. downloadFile로 설정해야 지정된 파일명을 viewer에서 인식
	- return으로 컨테이너에서 선언한 bean id(downloadviewer)를 호출
4. 상세화면 리스트에서 함수로 파일 다운 호출
	다운로드 Controller 호출
5. 해당 파일 클릭 시 다운로드 처리



		- 상세화면 보기
		- 수정
		- 삭제
		- 답글
	6) 계층형 리스트 처리하기
		- 계층형 SQL 작성
		- 조회 VO 할당
		- SERVICE단에서 BUSINESS로직 처리
		- 계층적 리스트 및 페이징
		

		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		